#!/usr/bin/env python3
from argparse import ArgumentParser
from typing import List, Tuple, Dict, Any

import dearpygui.dearpygui as dpg

from siebenapp.autolink import ToggleAutoLink
from siebenapp.domain import (
    Add,
    EdgeType,
    Select,
    ToggleClose,
    Delete,
    Insert,
    ToggleLink,
    HoldSelect,
    Rename,
    Graph,
)
from siebenapp.filter_view import FilterBy
from siebenapp.open_view import ToggleOpenView
from siebenapp.progress_view import ToggleProgress
from siebenapp.render import (
    Renderer,
    render_lines,
    GeometryProvider,
    Point,
    RenderResult,
    adjust_graph,
)
from siebenapp.switchable_view import ToggleSwitchableView
from siebenapp.system import load, split_long, save
from siebenapp.zoom import ToggleZoom


class DPGGeometry(GeometryProvider):
    DEFAULT_SIZE = (250, 30)

    def __init__(self, nodes: Dict[Tuple[int, int], Any], strict: bool = True):
        self.nodes = nodes
        self.strict = strict

    def _pos(self, row, col):
        if col < 0:
            return 0, self._pos(row, 0)[1]
        if self.strict and (row, col) in self.nodes:
            return dpg.get_item_pos(self.nodes[(row, col)])
        if col == 0:
            return 20, 50 + row * 100
        if not self.strict:
            x = col * (DPGGeometry.DEFAULT_SIZE[0] + 50) + 40
            y = row * (DPGGeometry.DEFAULT_SIZE[1] + 50) + 40
            return x, y
        left_pos = self._pos(row, col - 1)
        left_size = self._size(row, col - 1)
        return left_pos[0] + left_size[0] + 50, left_pos[1]

    def _size(self, row, col):
        if col < 0:
            return 0, self._size(row, 0)[1]
        if (row, col) in self.nodes:
            return dpg.get_item_rect_size(self.nodes[(row, col)])
        return DPGGeometry.DEFAULT_SIZE

    def top_left(self, row, col):
        pos = self._pos(row, col)
        return Point(pos[0], pos[1])

    def top_right(self, row, col):
        size = self._size(row, col)
        return self.top_left(row, col) + Point(size[0], 0)

    def bottom_left(self, row, col):
        size = self._size(row, col)
        return self.top_left(row, col) + Point(0, size[1])

    def bottom_right(self, row, col):
        size = self._size(row, col)
        return self.top_left(row, col) + Point(size[0], size[1])


def show_message(text):
    dpg.set_value("message", text)


class SiebenApp:
    def __init__(self, filename: str, font):
        self.filename: str = filename
        self.goaltree: Graph = load(self.filename, show_message)
        self.is_running: bool = True
        self.dialog_event_factory = None
        # zero -> loop [ goals -> adjust -> edges -> no_update -> ... ]
        self.phase: str = "zero"
        self.render_result: RenderResult = RenderResult({}, {})
        self.drawn_items: List[str] = []
        self.nodes: Dict[Tuple[int, int], Any] = {}
        self.columns: int = Renderer.DEFAULT_WIDTH
        self.font = font

    def text_width(self, text: str) -> int:
        size = dpg.get_text_size(text, font=self.font)
        return size[0] if size is not None else 0

    def open_file(self, sender, app_data, user_data):
        db_file = list(app_data.get("selections", {}).values())[:1]
        if db_file:
            self.filename = db_file[0]
            self.goaltree = load(self.filename, show_message)
            self.phase = "goals"

    def rebuild_goals(self):
        save(self.goaltree, self.filename)
        self.render_result = Renderer(self.goaltree, self.columns).build()
        gp = DPGGeometry(self.nodes)
        self.nodes.clear()
        while self.drawn_items:
            previous_tag = self.drawn_items.pop()
            dpg.delete_item(previous_tag)
        add_to_nodes = {}
        for goal_id, attrs in self.render_result.goals():
            goal_text = split_long(attrs["name"])
            row, col = attrs["row"], attrs["col"]
            pos = (-1000, -1000)
            status_color = (255, 0, 0, 255) if attrs["open"] else (0, 255, 0, 255)
            widget_tag = f"goal_{goal_id}"
            self.drawn_items.append(widget_tag)
            add_to_nodes[(row, col)] = widget_tag
            with dpg.group(pos=pos, parent="primary", tag=widget_tag):
                widget_width = (
                    self.text_width(goal_text) + self.text_width(str(goal_id)) + 20
                )
                if attrs["switchable"]:
                    widget_width += 50
                with dpg.table(
                    header_row=False,
                    borders_outerV=True,
                    borders_outerH=True,
                    width=widget_width,
                ) as table_id:
                    dpg.add_table_column()
                    with dpg.table_row():
                        with dpg.group(horizontal=True):
                            if attrs["switchable"]:
                                dpg.add_checkbox(
                                    default_value=not attrs["open"],
                                    tag=f"switch_{goal_id}",
                                )
                            dpg.add_text(str(goal_id), color=status_color)
                            dpg.add_text(goal_text)
                    if attrs["select"] == "select":
                        dpg.highlight_table_row(table_id, 0, (128, 128, 128, 255))
                    elif attrs["select"] == "prev":
                        dpg.highlight_table_row(table_id, 0, (192, 192, 192, 255))

            dpg.bind_item_handler_registry(widget_tag, "goals_handler")
            if attrs["switchable"]:
                dpg.bind_item_handler_registry(f"switch_{goal_id}", "switch_handler")
        self.nodes.update(add_to_nodes)
        self.phase = "adjust"

    def adjust_goals(self):
        # Do not use real coordinates of widgets because they're currently off-screen
        gp = DPGGeometry(self.nodes, False)
        adjust_graph(self.render_result, gp)
        for goal_id, attrs in self.render_result.goals():
            widget_tag = f"goal_{goal_id}"
            dpg.set_item_pos(widget_tag, [attrs["x"], attrs["y"]])
        self.phase = "edges"

    def rebuild_edges(self):
        line_color = {
            EdgeType.BLOCKER: (70, 70, 70, 255),
            EdgeType.PARENT: (180, 180, 180, 255),
        }
        lines = render_lines(DPGGeometry(self.nodes), self.render_result)
        fix = Point(0, -8)
        for edge_type, start, end, _ in lines:
            tag = f"line {edge_type} {start}, {end}"
            if tag in self.drawn_items:
                # lines may 'duplicate' when they're placed too close to each other
                # tag duplication causes an error within draw_line
                continue
            dpg.draw_line(
                (start + fix).as_tuple(),
                (end + fix).as_tuple(),
                color=line_color[edge_type],
                tag=tag,
                parent="primary",
            )
            self.drawn_items.append(tag)

        self.phase = "no_update"

    def submit_dialog(self, sender=None, app_data=None, user_data=None):
        user_input = dpg.get_value("dialog_input")
        self.goaltree.accept(self.dialog_event_factory(user_input))
        self.dialog_event_factory = None
        self.phase = "goals"
        dpg.delete_item("dialog")

    def close_dialog(self, sender=None, app_data=None, user_data=None):
        self.dialog_event_factory = None
        dpg.delete_item("dialog")

    def show_dialog(self, text, event_factory, default_value=""):
        self.dialog_event_factory = event_factory
        vp_width = dpg.get_viewport_width()
        vp_height = dpg.get_viewport_height()
        dialog_pos = (0, vp_height // 2)
        with dpg.window(
            id="dialog",
            modal=True,
            no_title_bar=True,
            pos=dialog_pos,
            width=vp_width - 10,
        ):
            with dpg.group(horizontal=True):
                dpg.add_text(text)
                dpg.add_input_text(tag="dialog_input", default_value=default_value)
                dpg.focus_item("dialog_input")
                with dpg.group():
                    dpg.add_button(
                        label="OK",
                        width=75,
                        callback=self.submit_dialog,
                    )
                    dpg.add_spacer(height=15)
                    dpg.add_button(label="Cancel", width=75, callback=self.close_dialog)

    def click_handler(self, sender, app_data):
        widget_id: str = app_data[1]
        goal_id = int(widget_id.split("_")[1])
        self.goaltree.accept(Select(goal_id))
        self.phase = "goals"

    def switch_handler(self, sender, app_data):
        widget_id: str = app_data[1]
        goal_id = int(widget_id.split("_")[1])
        self.goaltree.accept_all(Select(goal_id), ToggleClose())
        self.phase = "goals"

    def key_handler(self, sender, app_data):
        show_message("")
        if self.dialog_event_factory is not None:
            if app_data == 256:  # Esc
                self.close_dialog()
            elif app_data == 257:  # Enter
                self.submit_dialog()
            return
        if app_data == 81:  # q
            self.is_running = False
        elif 48 <= app_data <= 57:  # 0-9
            old_selection = self.goaltree.settings("selection")
            self.goaltree.accept(Select(app_data - 48))
            new_selection = self.goaltree.settings("selection")
            if old_selection != new_selection:
                self.phase = "goals"
        elif app_data == 65:  # a
            self.show_dialog("Add new goal", Add)
        elif app_data == 67:  # c
            self.goaltree.accept(ToggleClose())
            self.phase = "goals"
        elif app_data == 68:  # d
            self.goaltree.accept(Delete())
            self.phase = "goals"
        elif app_data == 70:  # f
            self.show_dialog(
                "Filter by substring (leave empty to reset filtration)", FilterBy
            )
        elif app_data == 73:  # i
            self.show_dialog("Insert new goal", Insert)
        elif app_data == 75:  # k
            self.goaltree.accept(ToggleLink(edge_type=EdgeType.PARENT))
            self.phase = "goals"
        elif app_data == 76:  # l
            self.goaltree.accept(ToggleLink())
            self.phase = "goals"
        elif app_data == 78:  # n
            self.goaltree.accept(ToggleOpenView())
            self.phase = "goals"
        elif app_data == 79:  # o
            dpg.show_item("open_dialog_id")
        elif app_data == 80:  # p
            self.goaltree.accept(ToggleProgress())
            self.phase = "goals"
        elif app_data == 82:  # r
            data = self.goaltree.q(keys="name,select").values()
            selected_text = [x["name"] for x in data if x["select"] == "select"].pop()
            self.show_dialog("Rename goal", Rename, selected_text)
        elif app_data == 84:  # t
            self.goaltree.accept(ToggleSwitchableView())
            self.phase = "goals"
        elif app_data == 90:  # z
            self.goaltree.accept(ToggleZoom())
            self.phase = "goals"
        elif app_data == 32:  # space
            self.goaltree.accept(HoldSelect())
            self.phase = "goals"
        elif app_data in (61, 334):  # +
            if self.columns < 100:
                self.columns += 1
                self.phase = "goals"
        elif app_data in (45, 333):  # -
            if self.columns > 1:
                self.columns -= 1
                self.phase = "goals"
        elif app_data == 96:  # `
            self.show_dialog(
                "Auto link by keyword (leave empty to reset auto link)", ToggleAutoLink
            )
        elif app_data not in (340, 341, 342, 343, 344, 345, 346):
            # ignore mod keys
            print(app_data)

    def frame(self):
        if self.phase == "goals":
            self.rebuild_goals()
        elif self.phase == "adjust":
            self.adjust_goals()
        elif self.phase == "edges":
            self.rebuild_edges()
        elif self.phase == "zero":
            self.phase = "goals"


def main():
    dpg.create_context()

    with dpg.font_registry():
        with dpg.font("Ubuntu-R.ttf", 14) as f1:
            dpg.add_font_range_hint(dpg.mvFontRangeHint_Cyrillic)
            default_font = f1

    dpg.create_viewport(title="SiebenApp")
    dpg.setup_dearpygui()
    parser = ArgumentParser()
    parser.add_argument(
        "db",
        nargs="?",
        default="sieben.db",
        help="Path to the database file (default: sieben.db)",
    )
    args = parser.parse_args()
    app = SiebenApp(args.db, default_font)

    with dpg.file_dialog(
        directory_selector=False,
        show=False,
        callback=app.open_file,
        width=500,
        height=300,
        tag="open_dialog_id",
    ):
        dpg.add_file_extension(".db", color=(255, 0, 255, 255), custom_text="[Sieben]")

    with dpg.window(tag="primary"):
        dpg.bind_font(default_font)
        dpg.add_text(default_value="", tag="message", pos=[5, 5])

    with dpg.handler_registry(tag="global_handler"):
        dpg.add_key_press_handler(callback=app.key_handler)

    with dpg.item_handler_registry(tag="goals_handler"):
        dpg.add_item_clicked_handler(callback=app.click_handler)

    with dpg.item_handler_registry(tag="switch_handler"):
        dpg.add_item_clicked_handler(callback=app.switch_handler)

    dpg.maximize_viewport()
    dpg.show_viewport()
    dpg.set_primary_window("primary", True)

    while dpg.is_dearpygui_running() and app.is_running:
        app.frame()
        dpg.render_dearpygui_frame()

    dpg.destroy_context()


if __name__ == "__main__":
    main()
